<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no, width=device-width">      
    <title>自定义三维图层</title>
	<link rel="stylesheet" href="https://a.amap.com/jsapi_demos/static/demo-center/css/demo-center.css" />
    <style>
        html,body,#container {
          width: 100%;
          height: 100%;
        }
    </style>
</head>
<body>
<div id="container"></div>
  <script>
    console.warn = console.log;
  </script>
<script src="//webapi.amap.com/maps?v=2.0&key=您申请的key值"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.142/build/three.js"></script>

<script>javascript: (function () { var script = document.createElement('script'); script.onload = function () { var stats = new Stats(); document.body.appendChild(stats.dom); requestAnimationFrame(function loop() { stats.update(); requestAnimationFrame(loop) }); }; script.src = 'https://mrdoob.github.io/stats.js/build/stats.min.js'; document.head.appendChild(script); })()</script>
<script type="text/javascript">
	var map = new AMap.Map('container', {
        center: [116.54, 39.79],
        zooms: [2, 20],
		zoom: 14,
        viewMode: '3D',
        pitch: 50,
	});
	
	var camera;
    var renderer;
    var scene;
    var meshes = [];
    // 数据转换工具
    var customCoords = map.customCoords;
    // 数据使用转换工具进行转换，这个操作必须要提前执行（在获取镜头参数 函数之前执行），否则将会获得一个错误信息。
    var data = customCoords.lngLatsToCoords([
        [116.52, 39.79],
        [116.54, 39.79],
        [116.56, 39.79],
    ]);
	
	// 创建 GL 图层
	var gllayer = new AMap.GLCustomLayer({
	    // 图层的层级
        zIndex: 10,
        // 初始化的操作，创建图层过程中执行一次。
        init: (gl) => {
            // 这里我们的地图模式是 3D，所以创建一个透视相机，相机的参数初始化可以随意设置，因为在 render 函数中，每一帧都需要同步相机参数，因此这里变得不那么重要。
            // 如果你需要 2D 地图（viewMode: '2D'），那么你需要创建一个正交相机
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 100, 1 << 30);
            
            renderer = new THREE.WebGLRenderer({
                context: gl,  // 地图的 gl 上下文
                // alpha: true,
                // antialias: true,
                // canvas: gl.canvas,
            });
            
            // 自动清空画布这里必须设置为 false，否则地图底图将无法显示
            renderer.autoClear = false;
            scene = new THREE.Scene();
            
            // 环境光照和平行光
            var aLight = new THREE.AmbientLight(0xffffff, 0.3); 
            var dLight = new THREE.DirectionalLight(0xffffff, 1);
            dLight.position.set(1000, -100, 900);
            scene.add(dLight);
            scene.add(aLight);

            // 创建范围墙
            createWall(map);
        },
        render: () => {
            // 这里必须执行！！重新设置 three 的 gl 上下文状态。
          	renderer.resetState();
            // 重新设置图层的渲染中心点，将模型等物体的渲染中心点重置
            // 否则和 LOCA 可视化等多个图层能力使用的时候会出现物体位置偏移的问题
            customCoords.setCenter([116.52, 39.79]);
            var { near, far, fov, up, lookAt, position } = customCoords.getCameraParams();
            
            // 2D 地图下使用的正交相机
            // var { near, far, top, bottom, left, right, position, rotation } = customCoords.getCameraParams();

            // 这里的顺序不能颠倒，否则可能会出现绘制卡顿的效果。
            camera.near = near;
            camera.far = far;
            camera.fov = fov;
            camera.position.set(...position);
            camera.up.set(...up);
            camera.lookAt(...lookAt);
            camera.updateProjectionMatrix();

            // 2D 地图使用的正交相机参数赋值
            // camera.top = top;
            // camera.bottom = bottom;
            // camera.left = left;
            // camera.right = right;
            // camera.position.set(...position);
            // camera.updateProjectionMatrix();
            
            renderer.render(scene, camera);
          
            // 这里必须执行！！重新设置 three 的 gl 上下文状态。
          	renderer.resetState();
        },
    });
    map.add(gllayer);


     /**
     * 创建范围墙
     * @param arr {Array} 范围路径, 可以是多个边界数组
     * 比如 [ [[x1,y1],[x2,y2]], [[x3,y3],[x4,y4],[x5,y5]]
     */
    function createWall (scene,map) {
        let that=this;
        this.color="#ff0000";
        // 请求路径
        // 居中最大化
        let districtSearch = new AMap.DistrictSearch({
            // 关键字对应的行政区级别，共有5种级别
            level: 'district',
            //  是否显示下级行政区级数，1表示返回下一级行政区
            subdistrict: 0,
            // 返回行政区边界坐标点
            extensions: 'all',
        })

        // 搜索所有省/直辖市信息
        districtSearch.search('余杭', (status, result) => {
            let bounds = result.districtList[0].boundaries[0];
            let boundsLength=bounds.length;
            let path=[];
            // 计算最大最小范围
            for(let i=boundsLength-1;i>=0;i-- ){
                let item=bounds[i];
                path.push(item.toArray());
            }
            path=that.customCoords.lngLatsToCoords(path);
            let paths=[path];

            // 添加墙
            let faceList = []
            let faceVertexUvs = []

            // 合并多个闭合范围
            for (let i = 0; i < paths.length; i++) {
                const { face, uvs } = that.generateVecData(paths[i])
                faceList = [...faceList, ...face]
                faceVertexUvs = [...faceVertexUvs, ...uvs]
            }

            // 垂直墙体A
            const geometry = new THREE.BufferGeometry()
            geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(faceList), 3))
            geometry.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(faceVertexUvs), 2))
            // 添加材质
            const material1 = new THREE.MeshBasicMaterial({
                color: that.color,
                side: THREE.DoubleSide,
                transparent: true,
                depthWrite: false,
                alphaMap: new THREE.TextureLoader().load(process.env.VUE_APP_URL+"/static/img/texture/wall.png")
            });
            const mesh1 = new THREE.Mesh(geometry, material1)
            scene.add(mesh1);

            // 拷贝垂直墙体A，在相同的位置添加一层垂直墙体B
            const geometry2 = geometry.clone();
            that.texture = that.generateTexture(128, that.color)
            that.texture.wrapS = THREE.RepeatWrapping // 水平重复平铺
            that.texture.wrapT = THREE.RepeatWrapping // 垂直重复平铺

            const material2 = new THREE.MeshBasicMaterial({
                side: THREE.DoubleSide,
                transparent: true,
                depthWrite: false,
                map: that.texture
            })
            const mesh2 = new THREE.Mesh(geometry2, material2)
            scene.add(mesh2);

            // 启动动画
            that.animateWall(map);
            
        });
    }

    /**
     * 创建一个闭合范围的模型数据
     * @param res {Object} 包含面的顶点数据face，UV面的顶点数据uvs
     */
    function generateVecData (arr) {
        let height=this.height;
        const vec3List = [] // 顶点数组
        let faceList = [] // 三角面数组
        let faceVertexUvs = [] // 面的UV层队列，用于纹理和几何信息映射

            //UV面的坐标声明
        const t0 = [0, 0]
        const t1 = [1, 0]
        const t2 = [1, 1]
        const t3 = [0, 1]

        for (let i = 0; i < arr.length; i++) {
        const [x1, y1] = arr[i]
        vec3List.push([x1, y1, 0])
        vec3List.push([x1, y1, height])
        }

        for (let i = 0; i < vec3List.length - 2; i++) {
        if (i % 2 === 0) {
            // 下三角顶点
            faceList = [...faceList, ...vec3List[i], ...vec3List[i + 2], ...vec3List[i + 1]]
            // 下三角UV面
            faceVertexUvs = [...faceVertexUvs, ...t0, ...t1, ...t3]
        } else {
            // 上三角顶点
            faceList = [...faceList, ...vec3List[i], ...vec3List[i + 1], ...vec3List[i + 2]]
            // 上三角UV面
            faceVertexUvs = [...faceVertexUvs, ...t3, ...t1, ...t2]
        }
        }

        return {
            face: faceList,
            uvs: faceVertexUvs
        }
    }

    /**
     * 生成材质
     * @param {*} size 
     * @param {*} color 
     * @returns 
     */
    function generateTexture(size = 64, color ="#ff0000"){
        let canvas = document.createElement('canvas')
        canvas.width = size
        canvas.height = size
        let ctx = canvas.getContext('2d')
        let linearGradient = ctx.createLinearGradient(0,0,0,size)
        linearGradient.addColorStop(0.2, hexToRgba(color, 0.0)) // 将16进制写法转换从rgba写法
        linearGradient.addColorStop(0.8, hexToRgba(color, 0.5))
        linearGradient.addColorStop(1.0, hexToRgba(color, 1.0))
        ctx.fillStyle = linearGradient
        ctx.fillRect(0,0, size, size)
        
        let texture = new THREE.Texture(canvas)
        texture.needsUpdate = true //必须
        return texture
    }

    /**
     * 渲染动画，墙体动画
     * @param {*} map 
     */
    function animateWall(map) {
        this.texture.offset.y-=this.texture_offset;
        map.render();
        requestAnimationFrame(()=>{
            this.animateWall(map);
        });
    }
    /**
     * 将hex转换为rgba
     * @returns 
     */
    let reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;  
    function hexToRgba(color,alpha){
        var sColor = color.toLowerCase();  
        if(sColor && reg.test(sColor)){  
            if(sColor.length === 4){  
                var sColorNew = "#";  
                for(let i=1; i<4; i+=1){  
                    sColorNew += sColor.slice(i,i+1).concat(sColor.slice(i,i+1));     
                }  
                sColor = sColorNew;  
            }  
            //处理六位的颜色值  
            let sColorChange = [];  
            for(let i=1; i<7; i+=2){  
                sColorChange.push(parseInt("0x"+sColor.slice(i,i+2)));    
            }  

            //转换为rgba,透明度为传递的参数x；
            return "rgba(" + sColorChange.join(",") + ","+alpha+")";

        }else{  
            return sColor;    
        }  
    }
    
    // 动画
    function animate() {
        for (let i = 0; i < meshes.length; i++) {
            let { mesh, count } = meshes[i];
            count += 1;
            mesh.rotateZ(count / 180 * Math.PI);
        }
        map.render();
        requestAnimationFrame(animate);
    }
    animate();
</script>
</body>  
</html>